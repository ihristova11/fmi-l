\section{Тема 15}

\subsection{Тегловни графи. Минимално покриващо дърво на тегловен граф. МПД свойство.}
\begin{definition}
    Тегловен ориентиран мултиграф е наредена четворка \mexpr{G = (V, E, f_G, w)}, където \(V\) е непразно 
    множество от върхове, \(E\) е множество от ребра, \mexpr{V \cap E = \emptyset, f_G: E \to V \times V} 
    е свързваща функция и \mexpr{w: E \to \mathbb{R}} е тегловната функция.
\end{definition}

\begin{note}
    Стойността \(w(e)\) за \(e \in E\), наричаме цена или тегло на реброто \(e\). \\
    Цена на покриващо дърво \mexpr{T = (V, E'), E' \subseteq E}, е сумата 
    \mexpr{w(T) = \sum_{e \in E'} w(e)}
\end{note}

\begin{definition}
    Покриващото дърво \(T\) на \(G\), наричаме \underline{минимално (максимално)}, ако 
    \mexpr{w(T) \le w(T')} (съответно \mexpr{w(T') \ge w(T)}) за всяко друго покриващо дърво \(T'\) на \(G\).
\end{definition}

\begin{theorem}[МПД-свойство]
    Нека \graf е свързан граф с тегловна функция \(w: E \to \mathbb{R}\) и \(U \subseteq V, U \not = 
    \emptyset\) е \(e = \{u, v\} \in E\) е такова, че \mexpr{u \in U, v \in V \setminus U} и измежду
    всички ребра \(e' = \{u', v'\}\) за \(u' \in U, v' \in V \setminus U\), реброто \(e\) е с 
    най-ниска цена, т.е. \(w(e) \le w(e')\). Тогава \(G\) има минимално покриващо дърво, в което 
    участва \(e\).
\end{theorem}

\begin{proof}
    Нека \(D(V, E_0)\) е минимално покриващо дърво. Да допуснем, че \(e\) не участва в \(E_0\). Тогава в 
    \(D\) има път от \(u\) до \(v\) - \(u = u_0, u_1, ..., u_k = v\). В този път участва поне едно ребро 
    \mexpr{e' = \{u_i, u_{i + 1}\}} такова, че \(u_i \in U\) и \(u_{i + 1} \in V \setminus U\). Така в 
    графа \mexpr{D' = (V, E_0 \cup \{e\})} има цикъл \mexpr{v, u = u_0, u_1, ..., u_k = v}. Тогава 
    графът \mexpr{D''= (V, (E_0 \cup \{e\}) \setminus \{e'\})} е свързан и има покриващо дърво \(V, E_1\), 
    където \mexpr{e \in E_1 \subseteq (E_0 \setminus \{e\}) \setminus \{e'\}}. По условие \(w(e) \le w(e')\), 
    следователно:
    \begin{equation*}
        \sum_{e \in E_1} w(e) \le \sum_{e \in (E_0 \cup \{e\}) \setminus \{e'\}} w(e) \le 
        \sum_{e \in E_0} w(e)
    \end{equation*}
\end{proof}

\subsection{Алгоритми на Прим и Крускал. Коректност на тези алгоритми.}

\begin{alg}[на Прим]
    Алгоритъмът на Прим строи МПД на \(G\). \\
    Вход: свързан граф \(G = (V, E)\) и ф-я \(w: E \to \mathbb{R}\), задаваща тегла на 
    ребрата му \\
    Изход: МПД \(D(V, E')\) с корен зададен връх \(r \in V\) на \(G\)
    \begin{enumerate}
        \item Построяваме дървото \(D_0(V_0, E_0), V_0 = \{r\}, E_0 = \emptyset, k = 0\)
        \item Нека сме построили \(D_k(V_k, E_k)\). Търсим реброто \(e = (v_i, v_j), v_i \in V_k, 
        v_j \in V \setminus V_k\) с минимално тегло и построяваме \(D_{k + 1} (V_{k + 1}, E_{k + 1}), 
        V_{k + 1} = V_k \cup \{v_j\}, E_{k + 1} = E_k \cup \{e\}, k = k + 1\)
        \item Ако \(V_k = V\), то полученото дърво \(D(V, E'), E' = E_k\) е оптималното и терминираме 
        алгоритъма, иначе отиваме на 2).
    \end{enumerate}
\end{alg}

\begin{proof}[Д-во за коректност???]
    За първата стъпка на алгоритъма избираме \(U = \{r\}\). Тогава трябва да изберем най-лекото ребро, 
    излизащо от \(r\) и алгоритъмът прави точно това. Щом избраното ребро на тази стъпка може да участва 
    в МПД, значи то образува сигурно за \(G\) м-во, а от друга страна е дърво - началото на 
    бъдещото МПД. От тук нататък, нека на всяка стъпка избираме за м-во \(U\) върховете \(V_i\) на 
    построената до момента част от МПД, а за \(A\) - участващите в него ребра \(E_i\). Тогава 
    най-лекото ребро от \(U\) към \(V \setminus U\) е сигурно за \(A = E_i\) и може да продължим с него 
    построяването на МПД. Това гарантира, че построеното от алгоритъма дърво е минимално.
\end{proof}

\begin{alg}[на Крускал]
    Алгоритъмът на Крускал строи МПД на \(G\). \\
    Вход:свързан граф \(G = (V, E)\) и ф-я \(w: E \to \mathbb{R}\), задаваща тегла на ребрата му \\
    Изход: МПД \(D = (V, E')\) на \(G\) \\
    \begin{enumerate}
        \item Сортираме ребрата на \(G\) в нарастващ ред по цената им и нека този ред е \(e_1, ..., e_m\)
        \item От всеки връх \(v\) на графа образуваме тривиално дърво \(D_V(\{v\}, \emptyset)\).
        \item За всяко ребро \(e_i = (v_{i_1}, v_{i_2}), i \in I_m\) правим следното: 
        ако \(v_{i_1}, v_{i_2}\) са в различни дървета, \(D'(V', E')\) и \(D''(V'', E'')\) 
        съответно, съединяваме двете в дървото \mexpr{D(V' \cup V'', E' \cup E'' \cup \{(v_{i_1}, v_{i_2})\})}.
    \end{enumerate}
\end{alg}

\begin{proof}[Д-во за коректност]
    Да допуснем, че алгоритъмът не е коректен, т.е. не съществува дърво с по-малка тегловност от този в 
    алгоритъма. \\
    Нека алгоритъмът бърка за реброто \(e_t\), което е било добавено и свърза две дървета \(T'\) и \(T''\).
    \begin{enumerate}
        \item Алгоритъмът е взел \(e_t\), защото между двете дървета няма друго ребро с по-малка тежест от 
        полученото \(\implies\) противоречие с допускането
        \item Ако \mexpr{w(e_i) \not = w(e_j)} за всяко \(i \not = j \implies\) съществува единствено 
        МПД, но ако има ребра с еднаква тежест, то ще има м-во от дървета.
    \end{enumerate}
\end{proof}
